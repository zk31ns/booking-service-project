name: Deploy to Production

on:
  push:
    branches:
      - main

env:
  DOCKER_IMAGE_NAME: booking-seats-api
  DEPLOY_PATH: /home/yc-user/booking_seats_team_project
  CONTAINER_NAME: booking_app

jobs:
  build_and_push:
    runs-on: ubuntu-latest
    name: Build and Push Docker Image

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: ./src
          file: ./src/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:buildcache,mode=max

  sync_code:
    runs-on: ubuntu-latest
    name: Sync Code to Server
    needs: build_and_push
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Sync code to server
        run: |
          rsync -avz --delete \
            -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            --exclude '.git' \
            --exclude '.github' \
            --exclude '.env' \
            --exclude 'infra/pgdata' \
            --exclude 'node_modules' \
            --exclude '__pycache__' \
            --exclude '*.pyc' \
            --exclude '.pytest_cache' \
            ./ ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:${{ env.DEPLOY_PATH }}/

  deploy_containers:
    runs-on: ubuntu-latest
    name: Deploy Docker Containers
    needs: sync_code
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Deploy application
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'DEPLOY_EOF'
            set -euo pipefail

            cd ${{ env.DEPLOY_PATH }}/infra

            # Export environment variables
            export IMAGE_TAG=${{ github.sha }}
            export DOCKER_IMAGE=${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}

            echo "ðŸ”„ Stopping old containers..."
            docker-compose down --remove-orphans || true

            echo "ðŸ“¥ Pulling latest Docker images..."
            docker-compose pull || {
              echo "âŒ Failed to pull images"
              exit 1
            }

            echo "ðŸš€ Starting containers..."
            docker-compose up -d || {
              echo "âŒ Failed to start containers"
              docker-compose logs --tail 50
              exit 1
            }

            # Wait for container to be healthy
            echo "â³ Waiting for container to be healthy..."
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            MAX_WAIT=300
            ELAPSED=0
            STABLE_COUNT=0
            REQUIRED_STABLE=3

            while [ $ELAPSED -lt $MAX_WAIT ]; do
              STATUS=$(docker inspect -f '{{.State.Status}}' "$CONTAINER_NAME" 2>/dev/null || echo "not_found")

              if [ "$STATUS" = "running" ]; then
                HEALTH=$(docker inspect -f '{{.State.Health.Status}}' "$CONTAINER_NAME" 2>/dev/null || echo "no-healthcheck")

                if [ "$HEALTH" = "healthy" ] || [ "$HEALTH" = "no-healthcheck" ]; then
                  STABLE_COUNT=$((STABLE_COUNT + 1))
                  echo "âœ… Container is running and healthy (${STABLE_COUNT}/${REQUIRED_STABLE})"

                  if [ $STABLE_COUNT -ge $REQUIRED_STABLE ]; then
                    echo "âœ… Container is stable!"
                    break
                  fi
                else
                  STABLE_COUNT=0
                  echo "â³ Container running but health check: $HEALTH"
                fi
              elif [ "$STATUS" = "restarting" ]; then
                STABLE_COUNT=0
                echo "â³ Container is restarting... (${ELAPSED}s elapsed)"
                # Show logs every 30 seconds to debug
                if [ $((ELAPSED % 30)) -eq 0 ]; then
                  echo "ðŸ“‹ Recent container logs (last 50 lines):"
                  docker logs --tail 50 "$CONTAINER_NAME" 2>&1 || true
                  echo ""
                  echo "ðŸ“‹ Docker-compose logs (app, last 30 lines):"
                  docker-compose logs --tail 30 app 2>&1 || true
                fi
              else
                STABLE_COUNT=0
                echo "â³ Container status: $STATUS (${ELAPSED}s elapsed)"
              fi

              sleep 5
              ELAPSED=$((ELAPSED + 5))
            done

            if [ $STABLE_COUNT -lt $REQUIRED_STABLE ]; then
              echo "âŒ Container did not become stable!"
              echo "Container status: $STATUS"
              echo ""
              echo "=== Container logs (last 100 lines) ==="
              docker logs --tail 100 "$CONTAINER_NAME" 2>&1 || true
              echo ""
              echo "=== Docker-compose logs (app service) ==="
              docker-compose logs --tail 100 app 2>&1 || true
              echo ""
              echo "=== Container inspect (State section) ==="
              docker inspect "$CONTAINER_NAME" 2>/dev/null | grep -A 30 "State" || true
              echo ""
              echo "=== Last exit code ==="
              docker inspect -f '{{.State.ExitCode}}' "$CONTAINER_NAME" 2>/dev/null || true
              exit 1
            fi

            echo "ðŸ“Š Container status:"
            docker-compose ps
          DEPLOY_EOF

  run_migrations:
    runs-on: ubuntu-latest
    name: Run Database Migrations
    needs: deploy_containers
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Run database migrations
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'MIGRATE_EOF'
            set -euo pipefail

            cd ${{ env.DEPLOY_PATH }}/infra

            export IMAGE_TAG=${{ github.sha }}
            export DOCKER_IMAGE=${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}

            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"

            # Ensure container is running
            for i in {1..10}; do
              STATUS=$(docker inspect -f '{{.State.Status}}' "$CONTAINER_NAME" 2>/dev/null || echo "not_found")

              if [ "$STATUS" = "running" ]; then
                echo "âœ… Container is running, proceeding with migrations..."
                break
              fi

              if [ $i -eq 10 ]; then
                echo "âŒ Container is not running! Status: $STATUS"
                exit 1
              fi

              echo "â³ Waiting for container... ($i/10)"
              sleep 3
            done

            # Run migrations with retry
            echo "ðŸ”„ Running database migrations..."
            MAX_RETRIES=3
            MIGRATION_SUCCESS=false

            for attempt in $(seq 1 $MAX_RETRIES); do
              echo "Attempt $attempt of $MAX_RETRIES..."
              if docker-compose exec -T app alembic upgrade head; then
                echo "âœ… Migrations completed successfully!"
                MIGRATION_SUCCESS=true
                break
              else
                MIGRATION_EXIT_CODE=$?
                echo "âš ï¸ Migration attempt $attempt failed with exit code $MIGRATION_EXIT_CODE"
                if [ $attempt -lt $MAX_RETRIES ]; then
                  echo "Retrying in 5 seconds..."
                  sleep 5
                else
                  echo "âŒ Migrations failed after $MAX_RETRIES attempts"
                  echo "Container logs:"
                  docker logs --tail 50 "$CONTAINER_NAME" 2>/dev/null || true
                fi
              fi
            done

            if [ "$MIGRATION_SUCCESS" = "false" ]; then
              exit 1
            fi
          MIGRATE_EOF

  health_check:
    runs-on: ubuntu-latest
    name: Health Check
    needs: run_migrations
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Health check
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'HEALTH_EOF'
            set -euo pipefail

            echo "ðŸ¥ Performing health check..."
            MAX_ATTEMPTS=30
            HEALTH_CHECK_SUCCESS=false

            for i in $(seq 1 $MAX_ATTEMPTS); do
              if curl -sf http://localhost:8000/api/v1/health > /dev/null 2>&1; then
                echo "âœ… Application is healthy!"
                HEALTH_CHECK_SUCCESS=true
                break
              fi

              echo "â³ Waiting for application to be ready... ($i/$MAX_ATTEMPTS)"
              sleep 2
            done

            if [ "$HEALTH_CHECK_SUCCESS" = "false" ]; then
              echo "âŒ Application health check failed"
              echo "Container logs:"
              docker logs --tail 50 "${{ env.CONTAINER_NAME }}" 2>/dev/null || true
              exit 1
            fi
          HEALTH_EOF

  deployment_summary:
    runs-on: ubuntu-latest
    name: Deployment Summary
    needs: [deploy_containers, run_migrations, health_check]
    if: always()

    steps:
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Deployment summary
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'SUMMARY_EOF'
            set -euo pipefail || true
            echo "ðŸ“‹ Deployment Summary:"
            echo "===================="
            echo "Commit: ${{ github.sha }}"
            echo "Branch: ${{ github.ref_name }}"
            echo ""
            echo "Container Status:"
            cd ${{ env.DEPLOY_PATH }}/infra || exit 0
            export IMAGE_TAG=${{ github.sha }}
            export DOCKER_IMAGE=${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}
            docker-compose ps || echo "âš ï¸ Could not get container status"
          SUMMARY_EOF

      # - name: Notify Telegram (Success)
        # if: success()
        # uses: appleboy/telegram-action@master
        # with:
        #   to: ${{ secrets.TELEGRAM_CHAT_ID }}
        #   token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        #   message: |
        #     âœ… Production Deployment Successful!
        #     Repository: Booking Seats API
        #     Branch: ${{ github.ref_name }}
        #     Commit: ${{ github.sha }}
        #     Server: ${{ secrets.DEPLOY_HOST }}

      # - name: Notify Telegram (Failure)
        # if: failure()
        # uses: appleboy/telegram-action@master
        # with:
        #   to: ${{ secrets.TELEGRAM_CHAT_ID }}
        #   token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        #   message: |
        #     âŒ Production Deployment Failed!
        #     Repository: Booking Seats API
        #     Branch: ${{ github.ref_name }}
        #     Commit: ${{ github.sha }}
        #     Error: Check GitHub Actions logs for details
        #     Server: ${{ secrets.DEPLOY_HOST }}
